package main

import (
	"bytes"
	"fmt"
	"github.com/bytedance/mockey"
	"github.com/kivihub/dupl/context"
	"github.com/kivihub/dupl/job"
	"github.com/kivihub/dupl/syntax"
	"github.com/kivihub/dupl/syntax/golang"
	"github.com/smartystreets/assertions"
	"github.com/smartystreets/goconvey/convey"
	"math"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestDuplForPath(t *testing.T) {
	context.IsDebug = true
	filePath := []string{"_input_example/clone_left.txt", "_input_example/clone_right.txt"}
	filePath = insertPackageInfo(filePath)
	os.Args = []string{"dupl", "-t=100", "-ft=20", "-fr=80", "-plumbing", "-verbose"}
	//os.Args = []string{"dupl", "-t=100", "-plumbing", "-verbose"}
	runMockMain(t, filePath, func(output string) {
		convey.So(strings.Count(output, "duplicate of"), assertions.ShouldEqual, 1)
	})
}

var IgnorePath = "_test.go"
var IgnoreContent = "(// Code generated by)|(// Autogenerated by)"

func TestDuplForDir(t *testing.T) {
	ignoreFilePathExpr = &IgnorePath
	ignoreFileContentExpr = &IgnoreContent
	dir := "_input_example/"
	os.Args = []string{"dupl", "-t=100", "-ft=20", "-fr=80", "-maxFileSize=100KB", "-plumbing", "-verbose", dir}
	main()
}

func TestPrintToken(t *testing.T) {
	context.IsDebug = true
	pathCha := make(chan string)
	schan := job.Parse(pathCha, math.MaxInt)
	tree, data, done := job.BuildTree(schan)
	pathCha <- "_input_example/simple_assign.txt"
	close(pathCha)
	<-done
	tree.Update(&syntax.Node{Type: -1})
	lastLine := 0
	for i, node := range *data {
		if node.StartLine != node.EndLine {
			continue
		}
		if lastLine != 0 && node.StartLine != lastLine {
			fmt.Printf("\n")
		}
		fmt.Printf("Line:%2d,  NodeIndex: %2d,  Type: %13s,  Source:  %s\n", node.StartLine, i, golang.NodeTypeString(node.Type), node.Source)
		lastLine = node.StartLine
	}
}

func insertPackageInfo(filePaths []string) []string {
	pkg := []byte("package demo\n")
	ret := make([]string, len(filePaths))
	for i, path := range filePaths {
		bytes, _ := os.ReadFile(path)
		if strings.Index(string(bytes), "package ") == 0 {
			tmp := path
			ret[i] = tmp
		} else {
			dir, file := filepath.Split(path)
			newPath := dir + "." + file
			bytes = append(pkg, bytes...)
			os.WriteFile(newPath, bytes, os.FileMode(0666))
			ret[i] = newPath
		}
	}
	return ret
}

func runMockMain(t *testing.T, filePath []string, processOutput func(string)) {
	mockey.PatchConvey("TestMockPath", t, func() {
		mockey.Mock(filesFeed).Return(func() chan string {
			fchan := make(chan string)
			go func() {
				for _, file := range filePath {
					fchan <- file
				}
				close(fchan)
			}()
			return fchan
		}()).Build()
		endCapture := captureStdout()
		main()
		capturedContent := endCapture()
		fmt.Print("Captured: ", capturedContent)
		processOutput(capturedContent)
	})
}

// captureStdout 目前只适合拦截少量输出，如果过大超过缓冲区，则会阻塞
func captureStdout() func() string {
	oldStdout := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w

	return func() string {
		w.Close()
		var buf bytes.Buffer
		buf.ReadFrom(r)
		os.Stdout = oldStdout
		return buf.String()
	}
}
